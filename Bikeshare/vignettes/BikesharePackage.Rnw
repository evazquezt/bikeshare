\documentclass{article}
%\VignetteIndexEntry{Using Bikeshare}
\begin{document}
\SweaveOpts{concordance=TRUE}

\title{The Bikeshare Package}
\author{Sara Kwasnick and John Sears}
\maketitle

\section{Motivation}
The Bikeshare package is designed to aid social science research into municipal bike-sharing programs.  Benefits of use are streamlined data loading (with out-of-the-box support for several city-specific formats), graphical data exploration via integration with Google Maps API, and geographic data manipulation such as car versus bike distance calculation.

Our goal for this package is to dramatically reduce the start-up costs of engaging in data-driven research in bikeshare systems. 

We loosely group our functionality into three functional groups: 
\begin{itemize}
\item[1.] Data loading and cleaning
\item[2.] Quantitative analysis
\item[3.] Visualization tools
\end{itemize}
To illustrate the utility of the \texttt{Bikeshare} package, we will run through an example use-case scenario based on publicly available data from Capital Bikeshare in Washington, DC.

\section{Loading the Data}
Bikeshare data typically comprises two data files: a list of stations and a list of data on individual trips.  The two datasets are tied together by station ID numbers.  In addition to station IDs, the station data contains: station name, latitude, longitude, number of bike spaces, installation date and removal date, if applicable. The trips data contains: start times, end times, start location, end location, bike ID number, and member type (for example, subscribers vs. one-time users).

The Bikeshare Package comes equipped with Q4 2010 data from Capital Bikeshare pre-loaded as a test dataset.  We load the station data as follows:
<<>>=
library(Bikeshare)
## Load station data.
stations = readStationData(system.file("extData/bikeStations.xml",
                    package="Bikeshare"),.cities()$WAS)
## Load trip data
bd = readTripData(system.file("extData/2010-4th-quarter.csv", 
                    package="Bikeshare"), .cities()$WAS, stations)
@
Note that for every city supported by the \texttt{Bikeshare} Package, we define an S4 BikeshareCity object accessible using \texttt{.cities()}.  All data cleaning is done behind the scenes. What we have now is a list of BikeshareStation objects containig station-level data and a BikeshareData object that wraps all of the trip data.  These two objects will constitute the working unit of analysis.

\section{Graphics}
At this point the data is ready for analysis.  Before developing any models, we gain insight into the data's structure using \texttt{Bikeshare}'s built-in visualization tools.  We can begin by simply viewing the locations of all stations in our dataset.
<<fig=TRUE>>=
plotStations(stations)
@

As we can see, the stations tend to be clustered in Northern Virginia and Northwest DC, and the topology of the landscape (visible on the map) appears to influence station location.  Next, we narrow our focus to only look at stations that are within a two kilometer bike ride of the station at Dupont Circle, station 31200.  To get a sense of the usage rates at each station, we use the \texttt{plotBubbles} tool.

<<fig=TRUE>>=
## Uses best biking path result from Google Maps API
#distances <- as.data.frame(t(getDistance(stations,fromSubset="stationId==31200",
#                        mode="bicycling")))
#closeStations <- (distances[,1] <= 3) | (rownames(distances)=="31200")
distances <- 20*runif(313)  ## until I can do queries again :\
closeStations <- distances <= 3
plotBubbles(bd, stationSubset=closeStations,zoom=14,alpha=.5)
@

To get a sense of which routes are most frequent amongst the stations within a 3 km ride of the Dupont Circle station, we can use the \texttt{plotTrips} function.

<<fig=TRUE>>=
plotTrips(bd,stationSubset=closeStations,zoom=14,alpha=.5)
@

\section{Analysis}
Now let's try some simple analysis. Suppose, for example, that we wanted to get a sense of how the total number of visits to a station correlates with the number of bike slots. 
<<fig=TRUE>>=
## convert the station data object to a dataframe
stationDF <- makeStationDataFrame(stations)
## Find total visits to each station
totalVisits <- getTotalVisits(bd)
names(totalVisits)[1] <- "stationId"

## Merge total visits data into stationDF
stationDF <- merge(stationDF, totalVisits)

## Run a simple linear regression of station visits on number of bikes
model <- lm(visits ~ numBikes, data=stationDF)
summary(model)
qplot(numBikes, visits, data=stationDF) + 
  geom_abline(intercept=coef(model)[1],slope=coef(model)[2])
@
Generally speaking, we may want to decrease the number of bike slots at points toward the bottom right, and increase the number of bike slots at points toward the top left. 

Now suppose we wanted to install a new station.  One way to get a sense of demand for that station is to look at the current usage rates of stations as a function of the proximity to- and attributes of- the next nearest station, controlling for number of bikes.  Of course we would also want to factor in outside data like zoning and population of the location, but in general this will give us a rough sense of what demand might be like at a new station.

For simplicity, we'll limit ourselves to stations in the \texttt{closeStations} subset.  

<<>>=
library(geosphere)
stationDF <- subset(makeStationDataFrame(stations),closeStations)
distMat <- distm(stationDF[,c("long","lat")])/1000 + 1e10*diag(dim(stationDF)[1])
closest <- apply(distMat,1,which.min)
stationDF$closestIndex <- closest

## Add a column to stationDF containing distance to the nearest station
index <- matrix(c(1:dim(distMat)[1],closest),ncol=2)
stationDF$closestStation <- distMat[index]

## Add a column to stationDF containing number of bikes at nearest station
stationDF$closestNumBikes <- stationDF$numBikes[closest]

## Add a column to stationDF containing total visits to station and total visits to closest station
totalVisits <- getTotalVisits(bd,stationSubset=closeStations)
names(totalVisits)[1] <- "stationId"
stationDF <- merge(stationDF,totalVisits)
stationDF$closestVisits <- stationDF$visits[closest]

## Try some simple linear models
model <- lm(visits ~ closestStation + closestNumBikes + closestVisits + numBikes,data=stationDF)
model <- lm(visits ~ closestVisits + closestStation,data=stationDF)
model <- lm(visits ~ closestStation,data=stationDF) ## something like this? easy...
summary(model)
@
In general, we can regress usage of station on distance of nearest n stations to try to predict demand at a new station.

To explore an alternative concept of "closeness" between stations, we can run the SimRank algorithm on station 31200.  This will give us the likelihood that a "random cyclist" departing from station 31200 traverses the system via each of the other stations.  The results are easy to visualize as a bubble plot weighted by the SimRank coefficients.
<<fig=TRUE>>=
stationDF <- makeStationDataFrame(stations)
stationDF$ranks <- data.frame(stationSimRank(bd,31200))[,1]

## visualize results using a bubble plot weighted by rank
center <- c(mean(stationDF$long),mean(stationDF$lat))
map <- get_map(location=center,zoom=13,scale = "auto",source="google")
b <- ggmap(map)
b + geom_point(data=stationDF, aes(x=long,y=lat,size=ranks),colour="red",alpha=.5)
@



\end{document}